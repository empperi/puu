(set-env!
  :source-paths   #{"src" "test"}
  :resource-paths #{"resources"}
  :dependencies '[[org.clojure/clojure "1.8.0"]
                  [adzerk/boot-test "1.1.0" :scope "test"]
                  [instaparse "1.4.1" :scope "test"]])

(System/setProperty "BOOT_EMIT_TARGET" "no")

(require
  '[boot.task.built-in :as built-in]
  '[adzerk.boot-test :refer :all]
  '[instaparse.core :as insta]
  '[clojure.edn :as edn])

(def project-info-path "./resources/project-info.edn")

(defn project [] (edn/read-string (slurp project-info-path)))

(defn- project-version->str [v]
  (format "%s.%s.%s%s"
          (:major v)
          (:minor v)
          (:hotfix v)
          (if (:snapshot v) "-SNAPSHOT" "")))

(defn- generate-lein-project-file! [& {:keys [keep-project] :or {:keep-project true}}]
  (let [pfile (clojure.java.io/file "project.clj")
        proj (project)]
    (if-not keep-project (.deleteOnExit pfile))
    (spit pfile (str "; Auto-generated by Boot, regenerate by executing: 'boot lein-generate'\n"
                  (pp-str
                    (list* 'defproject (:project proj) (project-version->str (:version proj))
                           [:dependencies (get-env :dependencies)]))))))

(deftask lein-generate
  "Generate a leiningen `project.clj` file for mainly to be used with Cursive."
  []
  (fn [next-handler]
    (fn [fileset]
      (generate-lein-project-file! :keep-project true)
      (next-handler fileset))))

(deftask puu-pom
  []
  (fn [next-handler]
    (fn [fileset]
      (((apply pom (flatten (seq (update (project) :version project-version->str)))) next-handler) fileset))))

(deftask artifact []
  "Builds an application artifact for the current version (no promotions)."
  []
  (comp (puu-pom)
        (aot :all true)
        (jar :file "puu.jar")
        (target)))

(deftask promote
  "Promotes version"
  [m major bool "Major version (x in x.y.z)"
   i minor bool "Minor version (y in x.y.z)"
   f hotfix bool "Hotfix version (z in x.y.z)"
   s snapshot bool "Should promotion be a snapshot version?"]
  (fn [next-handler]
    (fn [fileset]
      (if (< 1 (count (filter true? (vals (select-keys *opts* [:major :minor :hotfix])))))
        (boot.util/fail "Only one of major, minor or hotfix can be promoted at once\n")
        (let [proj (project)
              v (:version proj)
              new-v (cond
                      (true? (:major *opts*)) {:major (inc (:major v)) :minor 0 :hotfix 0}
                      (true? (:minor *opts*)) {:major (:major v) :minor (inc (:minor v)) :hotfix 0}
                      (true? (:hotfix *opts*)) {:major (:major v) :minor (:minor v) :hotfix (inc (:hotfix v))}
                      :default v)
              final-v (if (:snapshot *opts*)
                        (assoc new-v :snapshot true)
                        (assoc new-v :snapshot false))]
          (boot.util/info "Promoting to %s\n" (project-version->str final-v))
          (spit (clojure.java.io/file project-info-path) (assoc-in proj [:version] final-v))))
      (next-handler fileset))))

(deftask snapshot
  "Creates a new snapshot version promotion."
  [m major bool "Major version (x in x.y.z)"
   i minor bool "Minor version (y in x.y.z)"
   f hotfix bool "Hotfix version (z in x.y.z)"]
  (comp (apply promote (flatten (seq (assoc *opts* :snapshot true))))
        (lein-generate)))

(deftask release
  "Executes tests, promotes the current snapshot version to non-snapshot. Then updates project.clj and builds a release
   artifact.

   Fails if the current version is not a snapshot when executed."
  []
  (if (false? (:snapshot (:version (project))))
    (boot.util/fail "Current version is not a -SNAPSHOT version, cannot release.\n")
    (comp (test)
          (promote :snapshot false)
          (lein-generate)
          (artifact))))