(set-env!
  :source-paths   #{"src/clj" "src/cljc" "src/cljs"}
  :test-paths     #{"test/clj" "test/cljc" "test/cljs"}
  :resource-paths #{"resources"}
  :dependencies '[[org.clojure/clojure "1.8.0"]
                  [org.clojure/clojurescript "1.7.228"]
                  [org.clojure/core.async "0.2.374"]
                  [amalloy/ring-buffer "1.2"]
                  [adzerk/boot-test "1.1.0" :scope "test"]
                  [adzerk/boot-cljs "1.7.228-1" :scope "test"]
                  [crisptrutski/boot-cljs-test "0.2.2-SNAPSHOT" :scope "test"]
                  [instaparse "1.4.1" :scope "test"]])

(System/setProperty "BOOT_EMIT_TARGET" "no")

(require
  '[boot.task.built-in :as built-in]
  '[adzerk.boot-test :as t]
  '[instaparse.core :as insta]
  '[clojure.edn :as edn]
  '[crisptrutski.boot-cljs-test :refer [test-cljs prep-cljs-tests run-cljs-tests]]
  '[adzerk.boot-cljs :refer [cljs]])

(def project-info-path "./resources/project-info.edn")
(defn project [] (edn/read-string (slurp project-info-path)))

(defn- project-version->str [v]
  (format "%s.%s.%s%s"
          (:major v)
          (:minor v)
          (:hotfix v)
          (if (:snapshot v) "-SNAPSHOT" "")))

(task-options!
  aot {:namespace #{'puu.model}}
  cljs {:source-map true}
  test-cljs {:js-env :phantom})

(defn- generate-lein-project-file! [& {:keys [keep-project] :or {:keep-project true}}]
  (let [pfile (clojure.java.io/file "project.clj")
        proj (project)]
    (if-not keep-project (.deleteOnExit pfile))
    (spit pfile (str "; Auto-generated by Boot, regenerate by executing: 'boot lein-generate'\n"
                  (pp-str
                    (list* 'defproject (:project proj) (project-version->str (:version proj))
                           [:dependencies (get-env :dependencies)
                            :source-paths (vec (get-env :source-paths))
                            :test-paths   (vec (get-env :test-paths))]))))))

(deftask lein-generate
  "Generate a leiningen `project.clj` file for mainly to be used with Cursive."
  []
  (fn [next-handler]
    (fn [fileset]
      (generate-lein-project-file! :keep-project true)
      (next-handler fileset))))

(deftask puu-pom
  []
  (fn [next-handler]
    (fn [fileset]
      (((apply pom (flatten (seq (update (project) :version project-version->str)))) next-handler) fileset))))

(deftask cljs-test
  []
  (set-env! :source-paths (apply conj (get-env :source-paths) (get-env :test-paths)))
  (test-cljs :namespaces #{"puu.model-test"}))

(deftask test
  "Wraps adzerk.boot-test/test since it provides no way to set test-paths separately from source-paths
   except by setting it manually just before executing the tests."
  []
  (comp
    (t/test (set-env! :source-paths (apply conj (get-env :source-paths) (get-env :test-paths))))
    (cljs-test)))

(deftask package
  "Builds an application artifact for the current version (no promotions)."
  []
  (comp (puu-pom)
        (aot)
        (jar :file (let [{v :version} (project)]
                     (format "puu-%s.%s.%s%s.jar"
                             (:major v)
                             (:minor v)
                             (:hotfix v)
                             (if (:snapshot v) "-SNAPSHOT" ""))))
        (target)))

(deftask build
  "Runs tests, creates a package and installs it into local M2 repository."
  []
  (comp (test)
        (package)
        (built-in/install)))

(deftask promote
  "Promotes version"
  [m major bool "Major version (x in x.y.z)"
   i minor bool "Minor version (y in x.y.z)"
   f hotfix bool "Hotfix version (z in x.y.z)"
   s snapshot bool "Should promotion be a snapshot version?"]
  (fn [next-handler]
    (fn [fileset]
      (if (< 1 (count (filter true? (vals (select-keys *opts* [:major :minor :hotfix])))))
        (boot.util/fail "Only one of major, minor or hotfix can be promoted at once\n")
        (let [proj (project)
              v (:version proj)
              new-v (cond
                      (true? (:major *opts*)) {:major (inc (:major v)) :minor 0 :hotfix 0}
                      (true? (:minor *opts*)) {:major (:major v) :minor (inc (:minor v)) :hotfix 0}
                      (true? (:hotfix *opts*)) {:major (:major v) :minor (:minor v) :hotfix (inc (:hotfix v))}
                      :default v)
              final-v (if (:snapshot *opts*)
                        (assoc new-v :snapshot true)
                        (assoc new-v :snapshot false))]
          (boot.util/info "Promoting to %s\n" (project-version->str final-v))
          (spit (clojure.java.io/file project-info-path) (assoc-in proj [:version] final-v))))
      (next-handler fileset))))

(deftask snapshot
  "Creates a new snapshot version promotion."
  [m major bool "Major version (x in x.y.z)"
   i minor bool "Minor version (y in x.y.z)"
   f hotfix bool "Hotfix version (z in x.y.z)"]
  (comp (apply promote (flatten (seq (assoc *opts* :snapshot true))))
        (lein-generate)))

(deftask release
  "Executes tests, promotes the current snapshot version to non-snapshot. Then updates project.clj and builds a release
   artifact.

   Fails if the current version is not a snapshot when executed."
  []
  (if (false? (:snapshot (:version (project))))
    (boot.util/fail "Current version is not a -SNAPSHOT version, cannot release.\n")
    (comp (test)
          (promote :snapshot false)
          (lein-generate)
          (cljs :optimizations :advanced)
          (package))))

(deftask dev
  "Starts a watcher for tests and launches nrepl."
  []
  (comp (repl)
        (watch)
        (test)))